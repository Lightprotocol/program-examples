# ZK Vote - Anonymous Voting with ZK Compression

## Summary

- Anonymous voting using ZK proofs on Light Protocol's compression layer
- Voter identity hidden via credential + nullifier model (Groth16 proofs)
- Vote choices and tallies are public; only voter identity is private
- Double-vote prevention via nullifier-derived compressed account addresses
- Trustless cryptographic verification (no MPC nodes required)

## Architecture

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           ZK Vote Flow                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. SETUP                                                               │
│     Authority creates Poll PDA with question and 3 options              │
│                                                                         │
│  2. REGISTRATION                                                        │
│     Authority registers eligible voters → creates VoterCredential       │
│     (compressed account with Poseidon hash for ZK compatibility)        │
│                                                                         │
│  3. VOTING                                                              │
│     Voter generates ZK proof proving:                                   │
│     - "I own a valid credential for this poll"                          │
│     - "My nullifier is correctly derived from my private key"           │
│     Submits: proof + vote_choice (public)                               │
│     Creates: VoteRecord at nullifier-derived address (prevents reuse)   │
│     Updates: Poll.vote_counts[choice] += 1                              │
│                                                                         │
│  4. RESULTS                                                             │
│     Vote counts are public and verifiable in real-time                  │
│     Authority calls close_poll → emits winner                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## Privacy Properties

| Property | Value |
|----------|-------|
| Voter identity | Hidden (ZK proof hides which credential was used) |
| Vote choice | Public (visible on-chain in real-time) |
| Vote counts | Public (updated with each vote) |
| Double-vote prevention | Nullifier-derived address (cryptographic) |
| Trust model | Trustless (Groth16 proofs, no MPC nodes) |

## Source Structure

```text
zk-vote/
├── src/
│   ├── lib.rs              # Program entry, accounts, instructions, handlers
│   └── verifying_key.rs    # Groth16 verifying key (generated by setup.sh)
├── circuits/
│   ├── vote_proof.circom        # Main voting circuit (7 public inputs)
│   ├── credential.circom        # Keypair derivation: Poseidon(private_key)
│   ├── merkle_proof.circom      # 26-level Merkle tree verification
│   └── compressed_account.circom # Light Protocol account hash
├── scripts/
│   └── setup.sh            # Circuit compilation + trusted setup
├── build.rs                # Generates verifying_key.rs from JSON
└── Cargo.toml
```

## Accounts

### Poll (Solana PDA)

Stores poll metadata and vote tallies.

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `bump` | `u8` | 1 | PDA bump seed |
| `id` | `u32` | 4 | Unique poll identifier |
| `authority` | `Pubkey` | 32 | Poll creator (registers voters, closes poll) |
| `question` | `String` | 4 + len | Poll question (max 100 chars) |
| `options` | `[String; 3]` | variable | 3 voting options (max 50 chars each) |
| `vote_counts` | `[u64; 3]` | 24 | Public vote tallies |
| `is_open` | `bool` | 1 | Whether poll accepts votes |

**Derivation:** `[b"poll", authority.key(), poll_id.to_le_bytes()]`

### VoterCredential (Compressed, Poseidon)

Proves voter eligibility for a specific poll.

| Field | Type | Description |
|-------|------|-------------|
| `poll_id` | `u32` | Poll this credential is valid for |
| `credential_pubkey` | `[u8; 32]` | `Poseidon(credential_private_key)` |

**Address seeds:** `[b"voter", poll_id.to_le_bytes(), credential_pubkey]`

**Hashing:** Poseidon (required for ZK circuit compatibility)

### VoteRecord (Compressed, SHA256)

Prevents double-voting via address uniqueness.

| Field | Type | Description |
|-------|------|-------------|
| `nullifier` | `[u8; 32]` | `Poseidon(poll_id_hashed, credential_private_key)` |
| `poll_id` | `u32` | Poll this vote is for |
| `vote_choice` | `u8` | 0, 1, or 2 |
| `timestamp` | `i64` | Unix timestamp |

**Address seeds:** `[b"vote", nullifier, poll_id.to_le_bytes()]`

**Double-vote prevention:** Creating a second VoteRecord with the same nullifier fails because the address already exists.

## Instructions

### create_poll

Creates a new poll as a Solana PDA.

| Field | Value |
|-------|-------|
| **path** | [src/lib.rs:45](src/lib.rs#L45) |
| **instruction_data** | `poll_id: u32`, `question: String`, `option_0: String`, `option_1: String`, `option_2: String` |
| **accounts** | `authority` (signer, payer), `poll` (init PDA), `system_program` |
| **constraints** | `question.len() <= 100`, `option_*.len() <= 50` |

### register_voter

Registers an eligible voter by creating a compressed VoterCredential.

| Field | Value |
|-------|-------|
| **path** | [src/lib.rs:78](src/lib.rs#L78) |
| **instruction_data** | `proof: ValidityProof`, `address_tree_info`, `output_state_tree_index`, `credential_pubkey: [u8; 32]` |
| **accounts** | `authority` (signer, must be poll authority), `poll`, Light Protocol remaining accounts |
| **constraints** | `poll.is_open`, `authority == poll.authority` |

**Logic:**

1. Derive credential address from `[b"voter", poll_id, credential_pubkey]`
2. Create compressed VoterCredential with Poseidon hashing
3. CPI to Light System Program to commit to state tree

### vote

Submits a vote with ZK proof of credential ownership.

| Field | Value |
|-------|-------|
| **path** | [src/lib.rs:137](src/lib.rs#L137) |
| **instruction_data** | `proof: ValidityProof`, `address_tree_info`, `output_state_tree_index`, `input_root_index`, `vote_choice: u8`, `credential_proof: CompressedProof`, `nullifier: [u8; 32]` |
| **accounts** | `voter` (signer), `poll` (mut), `input_merkle_tree`, Light Protocol remaining accounts |
| **constraints** | `poll.is_open`, `vote_choice < 3`, valid ZK proof |

**Logic:**

1. Verify `vote_choice < 3`
2. Derive VoteRecord address from `[b"vote", nullifier, poll_id]`
3. Read Merkle root from input state tree
4. Hash public inputs for circuit:
   - `owner_hashed`: Program ID hashed to BN254
   - `merkle_tree_hashed`: State tree pubkey hashed
   - `discriminator`: VoterCredential discriminator (8 bytes, padded)
   - `poll_id_hashed`: Poll ID hashed
   - `expectedRoot`: Merkle tree root
   - `nullifier`: From instruction data
   - `vote_choice`: As 32-byte BE integer
5. Verify Groth16 proof using `groth16_solana`
6. Create VoteRecord at nullifier-derived address
7. Increment `poll.vote_counts[vote_choice]`
8. CPI to Light System Program

### close_poll

Closes the poll and emits the winner.

| Field | Value |
|-------|-------|
| **path** | [src/lib.rs:286](src/lib.rs#L286) |
| **accounts** | `authority` (signer, must be poll authority), `poll` (mut) |
| **constraints** | `poll.is_open`, `authority == poll.authority` |

**Logic:**

1. Set `poll.is_open = false`
2. Find index of max vote count
3. Emit `PollClosedEvent { poll_id, winner, vote_counts }`

## Circuit: vote_proof.circom

### Public Inputs (7)

| # | Signal | Description |
|---|--------|-------------|
| 1 | `owner_hashed` | Program ID hashed to BN254 field |
| 2 | `merkle_tree_hashed` | State tree pubkey hashed |
| 3 | `discriminator` | VoterCredential discriminator |
| 4 | `poll_id_hashed` | Poll ID hashed |
| 5 | `expectedRoot` | Merkle tree root from on-chain |
| 6 | `nullifier` | `Poseidon(poll_id_hashed, credentialPrivateKey)` |
| 7 | `vote_choice` | Vote (0, 1, or 2) - PUBLIC |

### Private Inputs

| Signal | Description |
|--------|-------------|
| `credentialPrivateKey` | Voter's secret key (32 bytes) |
| `leaf_index` | Position in Merkle tree for proof ordering |
| `account_leaf_index` | Compressed account format |
| `address` | Credential compressed account address |
| `pathElements[26]` | Merkle proof sibling hashes |

### Constraints

```text
1. credential_pubkey = Poseidon(credentialPrivateKey)
2. nullifier = Poseidon(poll_id_hashed, credentialPrivateKey)
3. data_hash = Poseidon(poll_id_hashed, credential_pubkey)
4. account_hash = CompressedAccountHash(owner_hashed, leaf_index, address,
                                        merkle_tree_hashed, discriminator, data_hash)
5. MerkleProof(account_hash, pathElements, leaf_index) = expectedRoot
6. vote_choice < 3
```

## Events

| Event | Fields | Emitted by |
|-------|--------|------------|
| `PollClosedEvent` | `poll_id: u32`, `winner: u8`, `vote_counts: [u64; 3]` | `close_poll` |

## Errors

| Code | Name | Cause |
|------|------|-------|
| 6000 | `QuestionTooLong` | Question exceeds 100 characters |
| 6001 | `OptionTooLong` | Option exceeds 50 characters |
| 6002 | `PollClosed` | Poll is not accepting votes |
| 6003 | `InvalidVoteChoice` | `vote_choice >= 3` |
| 6004 | `AccountNotEnoughKeys` | Missing Light Protocol accounts |

## Client-Side Proof Generation

```typescript
// 1. Voter generates keypair
const privateKey = randomBytes(32);
const publicKey = poseidon([privateKey]); // Credential pubkey

// 2. Authority registers voter (creates VoterCredential)
await program.methods.registerVoter(
    proof, addressTreeInfo, outputStateTreeIndex, publicKey
).rpc();

// 3. Voter generates nullifier for this poll
const pollIdHashed = poseidonHash(pollId);
const nullifier = poseidon([pollIdHashed, privateKey]);

// 4. Voter gets Merkle proof for their credential
const merkleProof = await getMerkleProof(credentialAddress);

// 5. Voter generates ZK proof using snarkjs/mopro
const { proof } = await snarkjs.groth16.fullProve(
    {
        owner_hashed: hashProgramId(programId),
        merkle_tree_hashed: hashPubkey(stateTree),
        discriminator: voterCredentialDiscriminator,
        poll_id_hashed: pollIdHashed,
        expectedRoot: merkleProof.root,
        nullifier: nullifier,
        vote_choice: 1, // Vote for option 1
        // Private inputs
        credentialPrivateKey: privateKey,
        leaf_index: merkleProof.leafIndex,
        account_leaf_index: credentialAccountLeafIndex,
        address: credentialAddress,
        pathElements: merkleProof.pathElements,
    },
    "build/vote_proof_js/vote_proof.wasm",
    "build/vote_proof_final.zkey"
);

// 6. Submit vote
await program.methods.vote(
    validityProof,
    addressTreeInfo,
    outputStateTreeIndex,
    inputRootIndex,
    1, // vote_choice
    compressProof(proof),
    nullifier
).rpc();
```

## Security

| Property | Mechanism |
|----------|-----------|
| Voter anonymity | ZK proof hides which credential owns the vote |
| Eligibility | VoterCredential exists in Merkle tree |
| Double-vote prevention | Nullifier-derived address uniqueness |
| Poll binding | Nullifier includes poll_id_hashed |
| Vote integrity | On-chain Groth16 proof verification |

## Setup

```bash
# Install dependencies and compile circuit
./scripts/setup.sh

# Build Solana program (generates verifying_key.rs)
cargo build-sbf

# Run tests
cargo test
```

## Dependencies

- Light Protocol SDK (compression, Merkle trees, CPIs)
- groth16-solana (on-chain proof verification)
- circomlib (Poseidon, comparators)
- snarkjs (circuit compilation, trusted setup)

## Comparison: Arcium Election vs ZK Vote

| Aspect | Arcium Election | ZK Vote |
|--------|-----------------|---------|
| Vote storage | Encrypted ciphertexts | Plaintext counts |
| Voter privacy | MPC encryption | ZK proof (nullifier) |
| Tally visibility | Hidden until reveal | Public real-time |
| Double-vote prevention | MPC state tracking | Nullifier address |
| Trust model | MPC nodes honest | Cryptographic (trustless) |
| Reveal mechanism | Authority calls reveal | Always visible |
| Compute model | Homomorphic-like | Proof verification |
